/**
 * Task decomposition schemas
 *
 * These schemas define the structure for breaking down tasks
 * into parallelizable subtasks for swarm execution.
 */
import { z } from "zod";

/**
 * Effort estimation for subtasks.
 *
 * Time ranges:
 * - `trivial`: < 5 minutes (simple rename, typo fix)
 * - `small`: 5-30 minutes (single function, simple feature)
 * - `medium`: 30 min - 2 hours (multi-file change, moderate complexity)
 * - `large`: 2+ hours (significant feature, refactoring)
 */
export const EffortLevelSchema = z.enum([
  "trivial",
  "small",
  "medium",
  "large",
]);
export type EffortLevel = z.infer<typeof EffortLevelSchema>;

/**
 * Dependency type between subtasks
 */
export const DependencyTypeSchema = z.enum([
  "blocks", // Must complete before dependent can start
  "requires", // Needs output from another task
  "related", // Informational relationship
]);
export type DependencyType = z.infer<typeof DependencyTypeSchema>;

/**
 * Subtask in a decomposition
 */
export const DecomposedSubtaskSchema = z.object({
  title: z.string().min(1),
  description: z.string(),
  files: z.array(z.string()), // File paths this subtask will modify
  estimated_effort: EffortLevelSchema,
  /** Potential risks or complications (e.g., 'tight coupling', 'data migration required', 'breaking change') */
  risks: z.array(z.string()).optional().default([]),
});
export type DecomposedSubtask = z.infer<typeof DecomposedSubtaskSchema>;

/**
 * Dependency between subtasks
 */
export const SubtaskDependencySchema = z.object({
  /** Zero-based index of the dependency source subtask */
  from: z.number().int().min(0),
  /** Zero-based index of the dependency target subtask */
  to: z.number().int().min(0),
  type: DependencyTypeSchema,
});
export type SubtaskDependency = z.infer<typeof SubtaskDependencySchema>;

/**
 * Full task decomposition result
 *
 * Returned by the decomposition agent, validated before spawning.
 */
export const TaskDecompositionSchema = z.object({
  task: z.string(), // Original task description
  /** Rationale for this decomposition strategy (why these subtasks, why this order) */
  reasoning: z.string().optional(),
  subtasks: z.array(DecomposedSubtaskSchema).min(1),
  dependencies: z.array(SubtaskDependencySchema).optional().default([]),
  /**
   * Context shared with all spawned agents.
   * Examples: API contracts, shared types, project conventions, architectural decisions.
   */
  shared_context: z.string().optional(),
});
export type TaskDecomposition = z.infer<typeof TaskDecompositionSchema>;

/**
 * Arguments for task decomposition
 */
export const DecomposeArgsSchema = z.object({
  task: z.string().min(1),
  max_subtasks: z.number().int().min(1).default(5),
  context: z.string().optional(),
});
export type DecomposeArgs = z.infer<typeof DecomposeArgsSchema>;

/**
 * Spawn result for a single agent
 */
export const SpawnedAgentSchema = z.object({
  bead_id: z.string(),
  /**
   * Agent Mail assigned name (e.g., 'BlueLake', 'CrimsonRiver').
   * Generated by Agent Mail on session init.
   */
  agent_name: z.string(),
  task_id: z.string().optional(), // OpenCode task ID
  status: z.enum(["pending", "running", "completed", "failed"]),
  files: z.array(z.string()), // Reserved files
  /**
   * Agent Mail reservation IDs for file locking.
   * Used to release locks on task completion via agentmail_release.
   */
  reservation_ids: z.array(z.number()).optional(),
});
export type SpawnedAgent = z.infer<typeof SpawnedAgentSchema>;

/**
 * Result of spawning a swarm
 */
export const SwarmSpawnResultSchema = z.object({
  epic_id: z.string(),
  coordinator_name: z.string(), // Agent Mail name of coordinator
  thread_id: z.string(), // Agent Mail thread for this swarm
  agents: z.array(SpawnedAgentSchema),
  started_at: z.string().datetime({ offset: true }), // ISO-8601 with timezone
});
export type SwarmSpawnResult = z.infer<typeof SwarmSpawnResultSchema>;

/**
 * Progress update from an agent
 */
export const AgentProgressSchema = z
  .object({
    bead_id: z.string(),
    agent_name: z.string(),
    status: z.enum(["in_progress", "blocked", "completed", "failed"]),
    progress_percent: z.number().min(0).max(100).optional(),
    message: z.string().optional(),
    files_touched: z.array(z.string()).optional(),
    blockers: z.array(z.string()).optional(),
    timestamp: z.string().datetime({ offset: true }), // ISO-8601 with timezone
  })
  .refine(
    (data) =>
      data.status !== "blocked" || (data.blockers && data.blockers.length > 0),
    { message: "blockers array required when status is 'blocked'" },
  );
export type AgentProgress = z.infer<typeof AgentProgressSchema>;

/**
 * Swarm status summary
 */
export const SwarmStatusSchema = z.object({
  epic_id: z.string(),
  total_agents: z.number().int().min(0),
  running: z.number().int().min(0),
  completed: z.number().int().min(0),
  failed: z.number().int().min(0),
  blocked: z.number().int().min(0),
  agents: z.array(SpawnedAgentSchema),
  last_update: z.string().datetime({ offset: true }), // ISO-8601 with timezone
});
export type SwarmStatus = z.infer<typeof SwarmStatusSchema>;
